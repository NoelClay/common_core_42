# Libft
당신의 첫 번째 라이브러리

## 요약
이 프로젝트는 당신의 프로그램에 필요한 다양한 범용 함수들을 포함하는 C 라이브러리를 코딩하는 것입니다.

버전: 19.0

---

## 목차
1. [소개](#i-소개)
2. [공통 지침](#ii-공통-지침)
3. [AI 지침](#iii-ai-지침)
4. [필수 과제](#iv-필수-과제)
   - 4.1 [기술적 고려사항](#iv1-기술적-고려사항)
   - 4.2 [Part 1 - Libc 함수](#iv2-part-1---libc-함수)
   - 4.3 [Part 2 - 추가 함수](#iv3-part-2---추가-함수)
   - 4.4 [Part 3 - 연결 리스트](#iv4-part-3---연결-리스트)
5. [README 요구사항](#v-readme-요구사항)
6. [제출 및 동료평가](#vi-제출-및-동료평가)

---

## I. 소개

매우 유용한 표준 함수들에 접근할 수 없다면 C 프로그래밍은 꽤 지루할 수 있습니다. 이 프로젝트는 이러한 함수들이 어떻게 작동하는지 이해하고, 직접 구현하며, 효과적으로 사용하는 법을 배우도록 돕는 것을 목표로 합니다. 당신은 자신만의 라이브러리를 만들게 되며, 이는 향후 C 스쿨 과제에서 매우 유용할 것입니다.

---

## II. 공통 지침

- 프로젝트는 C 언어로 작성되어야 합니다.
- 프로젝트는 Norm(규범)에 따라 작성되어야 합니다. 보너스 파일/함수가 있다면 이들도 norm 검사에 포함되며, norm 에러가 있을 경우 0점을 받게 됩니다.
- 함수들은 예기치 않게 종료되어서는 안 됩니다(세그멘테이션 폴트, 버스 에러, 더블 프리 등). 정의되지 않은 동작의 경우는 예외입니다. 이런 일이 발생하면 프로젝트는 작동하지 않는 것으로 간주되어 평가에서 0점을 받게 됩니다.
- 힙에 할당된 모든 메모리는 필요할 때 적절히 해제되어야 합니다. 메모리 누수는 용납되지 않습니다.
- 과제에서 요구하는 경우, `-Wall`, `-Wextra`, `-Werror` 플래그를 사용하여 소스 파일을 요구되는 출력으로 컴파일하는 Makefile을 제출해야 합니다. cc를 사용하여 컴파일합니다. 또한 Makefile은 불필요한 재링킹을 수행해서는 안 됩니다.
- Makefile은 최소한 `$(NAME)`, `all`, `clean`, `fclean`, `re` 규칙을 포함해야 합니다.
- 프로젝트에 보너스를 제출하려면 Makefile에 보너스 규칙을 포함해야 하며, 이는 프로젝트의 필수 부분에서 허용되지 않는 모든 다양한 헤더, 라이브러리 또는 함수들을 추가합니다. 과제에서 별도로 명시하지 않는 한 보너스는 `_bonus.{c/h}` 파일에 배치되어야 합니다. 필수 부분과 보너스 부분의 평가는 별도로 진행됩니다.
- 프로젝트에서 libft를 사용할 수 있다면, libft 폴더에 소스와 관련 Makefile을 복사해야 합니다. 프로젝트의 Makefile은 해당 Makefile을 사용하여 라이브러리를 컴파일한 다음 프로젝트를 컴파일해야 합니다.
- 프로젝트를 위한 테스트 프로그램을 만들 것을 권장합니다. 이 작업은 제출할 필요가 없으며 채점되지 않습니다. 이를 통해 자신의 작업과 동료의 작업을 쉽게 테스트할 수 있는 기회를 얻게 됩니다. 이러한 테스트는 디펜스(평가) 중에 특히 유용할 것입니다. 실제로 디펜스 중에는 자신의 테스트 및/또는 평가하는 동료의 테스트를 자유롭게 사용할 수 있습니다.
- 할당된 Git 저장소에 작업을 제출하세요. Git 저장소의 작업만 채점됩니다. Deepthought가 작업을 채점하도록 할당된 경우, 동료 평가 후에 수행됩니다. Deepthought의 채점 중 작업의 어느 부분에서든 오류가 발생하면 평가가 중단됩니다.

---

## III. AI 지침

### 맥락
이 프로젝트는 42 교육의 기본 구성 요소를 발견하도록 돕기 위해 설계되었습니다.

핵심 지식과 기술을 제대로 정착시키려면 AI 도구와 지원을 사용하는 데 있어 신중한 접근 방식을 채택하는 것이 필수적입니다.

진정한 기초 학습은 도전, 반복, 그리고 동료 학습 교류를 통한 진정한 지적 노력을 필요로 합니다.

학습 도구로서의 AI, 42 교육의 일부로서의 AI, 그리고 취업 시장에서의 기대에 대한 우리의 입장을 더 완전히 이해하려면 인트라넷의 전용 FAQ를 참조하십시오.

### 주요 메시지
☛ 지름길 없이 강력한 기초를 구축하세요.
☛ 기술 및 역량 스킬을 실제로 개발하세요.
☛ 진정한 동료 학습을 경험하고, 학습 방법과 새로운 문제 해결 방법을 배우기 시작하세요.
☛ 학습 여정이 결과보다 더 중요합니다.
☛ AI와 관련된 위험에 대해 배우고, 일반적인 함정을 피하기 위한 효과적인 제어 방법과 대응책을 개발하세요.

### 학습자 규칙
- 특히 AI를 사용하기 전에 할당된 작업에 추론을 적용해야 합니다.
- AI에게 직접적인 답을 요구해서는 안 됩니다.
- AI에 대한 42의 전반적인 접근 방식에 대해 배워야 합니다.

### 단계 결과
이 기초 단계에서 다음과 같은 결과를 얻게 됩니다:
- 적절한 기술 및 코딩 기초를 얻습니다.
- 이 단계에서 AI가 왜, 어떻게 위험할 수 있는지 알게 됩니다.

### 의견 및 예시
- 네, 우리는 AI가 존재한다는 것을 압니다. 그리고 네, AI는 당신의 프로젝트를 해결할 수 있습니다. 하지만 당신은 배우기 위해 여기 있는 것이지, AI가 학습했다는 것을 증명하기 위해 있는 것이 아닙니다. AI가 주어진 문제를 해결할 수 있다는 것을 보여주기 위해 당신의 시간(또는 우리의 시간)을 낭비하지 마십시오.
- 42에서의 학습은 답을 아는 것이 아니라, 답을 찾는 능력을 개발하는 것입니다. AI는 직접적으로 답을 제공하지만, 그것은 당신 자신의 추론을 구축하는 것을 방해합니다. 그리고 추론은 시간, 노력, 그리고 실패를 수반합니다. 성공으로 가는 길은 쉬워서는 안 됩니다.
- 시험 중에는 AI를 사용할 수 없다는 점을 명심하세요. 인터넷도, 스마트폰도 없습니다. 학습 과정에서 AI에 너무 많이 의존했는지 금방 깨닫게 될 것입니다.
- 동료 학습은 당신을 다양한 아이디어와 접근 방식에 노출시켜 대인 관계 기술과 발산적 사고 능력을 향상시킵니다. 이것은 봇과 대화하는 것보다 훨씬 더 가치 있습니다. 그러니 부끄러워하지 말고 대화하고, 질문하고, 함께 배우세요!
- 네, AI는 커리큘럼의 일부가 될 것입니다. 학습 도구로서도, 그 자체로 주제로서도요. 심지어 자신만의 AI 소프트웨어를 구축할 기회도 갖게 될 것입니다. 인트라넷에서 제공되는 문서에서 여러분이 거치게 될 점진적 접근 방식에 대해 더 알아보세요.

✓ **좋은 관행:**
새로운 개념에서 막혔습니다. 근처에 있는 사람에게 그들이 어떻게 접근했는지 물어봅니다. 10분 동안 이야기를 나누면 갑자기 이해가 됩니다. 깨달았습니다.

✗ **나쁜 관행:**
몰래 AI를 사용하고, 올바르게 보이는 코드를 복사합니다. 동료 평가 중에 아무것도 설명할 수 없습니다. 실패합니다. 시험 중에는 AI가 없어 다시 막힙니다. 실패합니다.

---

## IV. 필수 과제

| 항목 | 내용 |
|------|------|
| **프로그램 이름** | libft.a |
| **제출 파일** | Makefile, libft.h, ft_*.c |
| **Makefile** | NAME, all, clean, fclean, re |
| **외부 함수** | 아래 상세 설명 |
| **Libft 허용** | 해당 없음 |
| **설명** | 자신만의 라이브러리를 만드세요: 커리큘럼에 유용한 도구가 될 함수 모음입니다. |

### IV.1 기술적 고려사항

- 전역 변수 선언은 엄격히 금지됩니다.
- 더 복잡한 함수를 분해하기 위해 헬퍼 함수가 필요한 경우, 해당 파일에 범위를 제한하기 위해 정적 함수로 정의하세요.
- 모든 파일은 저장소의 루트에 배치되어야 합니다.
- 사용되지 않는 파일을 제출하는 것은 허용되지 않습니다.
- 모든 `.c` 파일은 다음 플래그로 컴파일되어야 합니다: `-Wall -Wextra -Werror`
- 라이브러리를 생성하려면 `ar` 명령을 사용해야 합니다. `libtool`의 사용은 엄격히 금지됩니다.
- `libft.a`는 저장소의 루트에 생성되어야 합니다.

### IV.2 Part 1 - Libc 함수

시작하려면 libc의 함수 세트를 재구현해야 합니다. 당신의 버전은 원본과 동일한 프로토타입과 동작을 가지며, man 페이지의 정의를 엄격히 준수합니다. 유일한 차이점은 이름으로, 'ft_' 접두사로 시작해야 합니다. 예를 들어, strlen은 ft_strlen이 됩니다.

> **참고:** 재구현해야 하는 일부 함수 프로토타입은 'restrict' 한정자를 사용합니다. 이 키워드는 C99 표준의 일부입니다. 따라서 자신의 프로토타입에 포함하거나 `-std=c99` 플래그로 코드를 컴파일하는 것은 금지됩니다.

외부 함수에 의존하지 않고 다음 원본 함수들을 구현하는 자신만의 함수를 작성해야 합니다.

> **참고:** 문자 분류 함수(isalpha, isdigit, isalnum, isascii, isprint)의 경우, 반환 값은 다음과 같아야 합니다:
> - 문자가 테스트된 클래스와 일치하면 1
> - 문자가 일치하지 않으면 0

**구현해야 할 함수 목록:**
- isalpha
- isdigit
- isalnum
- isascii
- isprint
- strlen
- memset
- bzero
- memcpy
- memmove
- strlcpy
- strlcat
- toupper
- tolower
- strchr
- strrchr
- strncmp
- memchr
- memcmp
- strnstr
- atoi

다음 두 함수를 구현하기 위해서는 `malloc()`을 사용해야 합니다:
- calloc
- strdup

> **참고:** 현재 운영 체제에 따라 'calloc' 함수의 동작이 man 페이지 설명과 다를 수 있습니다. 다음 규칙을 따라야 합니다: nmemb 또는 size가 0이면, calloc()은 free()에 성공적으로 전달될 수 있는 고유한 포인터 값을 반환합니다.

> **참고:** strlcpy, strlcat, bzero와 같이 재구현해야 하는 일부 함수는 GNU C 라이브러리(glibc)에 기본적으로 포함되어 있지 않습니다. 시스템 표준과 비교하여 테스트하려면 `<bsd/string.h>`를 포함하고 `-lbsd` 플래그로 컴파일해야 할 수 있습니다. 이 동작은 glibc 시스템에 특정합니다. 궁금하다면 glibc와 BSD libc 간의 차이점을 탐구할 기회를 가지세요.

### IV.3 Part 2 - 추가 함수

이 두 번째 부분에서는 libc에 포함되지 않았거나 다른 형태로 존재하는 함수 세트를 개발해야 합니다.

> **참고:** Part 1의 일부 함수는 아래 함수를 구현하는 데 유용할 수 있습니다.

---

#### ft_substr

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_substr |
| **프로토타입** | `char *ft_substr(char const *s, unsigned int start, size_t len);` |
| **제출 파일** | - |
| **매개변수** | s: 부분 문자열을 생성할 원본 문자열.<br>start: 문자열 's' 내에서 부분 문자열의 시작 인덱스.<br>len: 부분 문자열의 최대 길이. |
| **반환 값** | 부분 문자열.<br>할당 실패 시 NULL. |
| **외부 함수** | malloc |
| **설명** | 메모리를 할당하고(malloc(3) 사용) 문자열 's'로부터 부분 문자열을 반환합니다. 부분 문자열은 인덱스 'start'에서 시작하고 최대 길이 'len'을 가집니다. |

---

#### ft_strjoin

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_strjoin |
| **프로토타입** | `char *ft_strjoin(char const *s1, char const *s2);` |
| **제출 파일** | - |
| **매개변수** | s1: 접두사 문자열.<br>s2: 접미사 문자열. |
| **반환 값** | 새로운 문자열.<br>할당 실패 시 NULL. |
| **외부 함수** | malloc |
| **설명** | 메모리를 할당하고(malloc(3) 사용) 's1'과 's2'를 연결한 결과인 새 문자열을 반환합니다. |

---

#### ft_strtrim

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_strtrim |
| **프로토타입** | `char *ft_strtrim(char const *s1, char const *set);` |
| **제출 파일** | - |
| **매개변수** | s1: 다듬을 문자열.<br>set: 제거할 문자 집합을 포함하는 문자열. |
| **반환 값** | 다듬어진 문자열.<br>할당 실패 시 NULL. |
| **외부 함수** | malloc |
| **설명** | 메모리를 할당하고(malloc(3) 사용) 's1'의 시작과 끝에서 'set'의 문자들이 제거된 복사본을 반환합니다. |

---

#### ft_split

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_split |
| **프로토타입** | `char **ft_split(char const *s, char c);` |
| **제출 파일** | - |
| **매개변수** | s: 분할할 문자열.<br>c: 구분 문자. |
| **반환 값** | 분할 결과로 생성된 새 문자열 배열.<br>할당 실패 시 NULL. |
| **외부 함수** | malloc, free |
| **설명** | 메모리를 할당하고(malloc(3) 사용) 문자 'c'를 구분자로 사용하여 's'를 분할하여 얻은 문자열 배열을 반환합니다. 배열은 NULL 포인터로 끝나야 합니다. |

---

#### ft_itoa

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_itoa |
| **프로토타입** | `char *ft_itoa(int n);` |
| **제출 파일** | - |
| **매개변수** | n: 변환할 정수. |
| **반환 값** | 정수를 나타내는 문자열.<br>할당 실패 시 NULL. |
| **외부 함수** | malloc |
| **설명** | 메모리를 할당하고(malloc(3) 사용) 인수로 받은 정수를 나타내는 문자열을 반환합니다. 음수는 처리되어야 합니다. |

---

#### ft_strmapi

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_strmapi |
| **프로토타입** | `char *ft_strmapi(char const *s, char (*f)(unsigned int, char));` |
| **제출 파일** | - |
| **매개변수** | s: 반복할 문자열.<br>f: 각 문자에 적용할 함수. |
| **반환 값** | 'f'의 연속적인 적용으로부터 생성된 문자열.<br>할당 실패 시 NULL을 반환합니다. |
| **외부 함수** | malloc |
| **설명** | 문자열 s의 각 문자에 함수 f를 적용하며, 인덱스를 첫 번째 인수로, 문자 자체를 두 번째 인수로 전달합니다. f의 연속적인 적용 결과를 저장하기 위해 새 문자열이 생성됩니다(malloc(3) 사용). |

---

#### ft_striteri

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_striteri |
| **프로토타입** | `void ft_striteri(char *s, void (*f)(unsigned int, char*));` |
| **제출 파일** | - |
| **매개변수** | s: 반복할 문자열.<br>f: 각 문자에 적용할 함수. |
| **반환 값** | 없음 |
| **외부 함수** | 없음 |
| **설명** | 인수로 전달된 문자열의 각 문자에 함수 'f'를 적용하며, 인덱스를 첫 번째 인수로 전달합니다. 각 문자는 주소로 'f'에 전달되므로 필요한 경우 수정될 수 있습니다. |

---

#### ft_putchar_fd

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_putchar_fd |
| **프로토타입** | `void ft_putchar_fd(char c, int fd);` |
| **제출 파일** | - |
| **매개변수** | c: 출력할 문자.<br>fd: 쓰기를 수행할 파일 디스크립터. |
| **반환 값** | 없음 |
| **외부 함수** | write |
| **설명** | 문자 'c'를 지정된 파일 디스크립터에 출력합니다. |

---

#### ft_putstr_fd

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_putstr_fd |
| **프로토타입** | `void ft_putstr_fd(char *s, int fd);` |
| **제출 파일** | - |
| **매개변수** | s: 출력할 문자열.<br>fd: 쓰기를 수행할 파일 디스크립터. |
| **반환 값** | 없음 |
| **외부 함수** | write |
| **설명** | 문자열 's'를 지정된 파일 디스크립터에 출력합니다. |

---

#### ft_putendl_fd

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_putendl_fd |
| **프로토타입** | `void ft_putendl_fd(char *s, int fd);` |
| **제출 파일** | - |
| **매개변수** | s: 출력할 문자열.<br>fd: 쓰기를 수행할 파일 디스크립터. |
| **반환 값** | 없음 |
| **외부 함수** | write |
| **설명** | 문자열 's'를 지정된 파일 디스크립터에 출력한 후 개행 문자를 출력합니다. |

---

#### ft_putnbr_fd

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_putnbr_fd |
| **프로토타입** | `void ft_putnbr_fd(int n, int fd);` |
| **제출 파일** | - |
| **매개변수** | n: 출력할 정수.<br>fd: 쓰기를 수행할 파일 디스크립터. |
| **반환 값** | 없음 |
| **외부 함수** | write |
| **설명** | 정수 'n'을 지정된 파일 디스크립터에 출력합니다. |

---

### IV.4 Part 3 - 연결 리스트

메모리 및 문자열 조작 함수는 유용합니다. 하지만 곧 리스트를 조작하는 것이 훨씬 더 유용하다는 것을 발견하게 될 것입니다.

이 세 번째 부분에서는 연결 리스트를 조작하기 위한 구조체를 사용하여 함수를 구현해야 합니다. 이를 위해 `libft.h` 파일에 다음 구조체 선언을 추가하세요:

```c
typedef struct s_list
{
    void *content;
    struct s_list *next;
} t_list;
```

`t_list` 구조체의 멤버는 다음과 같습니다:
- **content**: 노드에 포함된 데이터. `void *`를 사용하면 모든 유형의 데이터를 저장할 수 있습니다.
- **next**: 다음 노드의 주소, 또는 현재 노드가 마지막 노드인 경우 NULL.

리스트를 쉽게 사용하기 위해 다음 함수들을 구현하세요:

---

#### ft_lstnew

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstnew |
| **프로토타입** | `t_list *ft_lstnew(void *content);` |
| **제출 파일** | - |
| **매개변수** | content: 새 노드에 저장할 내용. |
| **반환 값** | 새 노드에 대한 포인터 |
| **외부 함수** | malloc |
| **설명** | 메모리를 할당하고(malloc(3) 사용) 새 노드를 반환합니다. 'content' 멤버 변수는 주어진 매개변수 'content'로 초기화됩니다. 변수 'next'는 NULL로 초기화됩니다. |

---

#### ft_lstadd_front

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstadd_front |
| **프로토타입** | `void ft_lstadd_front(t_list **lst, t_list *new);` |
| **제출 파일** | - |
| **매개변수** | lst: 리스트의 첫 번째 노드에 대한 포인터의 주소.<br>new: 추가할 노드에 대한 포인터의 주소. |
| **반환 값** | 없음 |
| **외부 함수** | 없음 |
| **설명** | 노드 'new'를 리스트의 시작 부분에 추가합니다. |

---

#### ft_lstsize

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstsize |
| **프로토타입** | `int ft_lstsize(t_list *lst);` |
| **제출 파일** | - |
| **매개변수** | lst: 리스트의 시작 부분. |
| **반환 값** | 리스트의 길이 |
| **외부 함수** | 없음 |
| **설명** | 리스트의 노드 수를 셉니다. |

---

#### ft_lstlast

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstlast |
| **프로토타입** | `t_list *ft_lstlast(t_list *lst);` |
| **제출 파일** | - |
| **매개변수** | lst: 리스트의 시작 부분. |
| **반환 값** | 리스트의 마지막 노드 |
| **외부 함수** | 없음 |
| **설명** | 리스트의 마지막 노드를 반환합니다. |

---

#### ft_lstadd_back

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstadd_back |
| **프로토타입** | `void ft_lstadd_back(t_list **lst, t_list *new);` |
| **제출 파일** | - |
| **매개변수** | lst: 리스트의 첫 번째 노드에 대한 포인터의 주소.<br>new: 추가할 노드에 대한 포인터의 주소. |
| **반환 값** | 없음 |
| **외부 함수** | 없음 |
| **설명** | 노드 'new'를 리스트의 끝에 추가합니다. |

---

#### ft_lstdelone

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstdelone |
| **프로토타입** | `void ft_lstdelone(t_list *lst, void (*del)(void *));` |
| **제출 파일** | - |
| **매개변수** | lst: 해제할 노드.<br>del: 내용을 삭제하는 데 사용되는 함수의 주소. |
| **반환 값** | 없음 |
| **외부 함수** | free |
| **설명** | 노드를 매개변수로 받고 함수 'del'을 사용하여 내용을 해제합니다. 노드 자체를 해제하지만 다음 노드는 해제하지 않습니다. |

---

#### ft_lstclear

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstclear |
| **프로토타입** | `void ft_lstclear(t_list **lst, void (*del)(void *));` |
| **제출 파일** | - |
| **매개변수** | lst: 노드에 대한 포인터의 주소.<br>del: 노드의 내용을 삭제하는 데 사용되는 함수의 주소. |
| **반환 값** | 없음 |
| **외부 함수** | free |
| **설명** | 함수 'del'과 free(3)를 사용하여 주어진 노드와 모든 후속 노드를 삭제하고 해제합니다. 마지막으로 리스트에 대한 포인터를 NULL로 설정합니다. |

---

#### ft_lstiter

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstiter |
| **프로토타입** | `void ft_lstiter(t_list *lst, void (*f)(void *));` |
| **제출 파일** | - |
| **매개변수** | lst: 노드에 대한 포인터의 주소.<br>f: 각 노드의 내용에 적용할 함수의 주소. |
| **반환 값** | 없음 |
| **외부 함수** | 없음 |
| **설명** | 리스트 'lst'를 반복하고 각 노드의 내용에 함수 'f'를 적용합니다. |

---

#### ft_lstmap

| 항목 | 내용 |
|------|------|
| **함수 이름** | ft_lstmap |
| **프로토타입** | `t_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));` |
| **제출 파일** | - |
| **매개변수** | lst: 노드에 대한 포인터의 주소.<br>f: 각 노드의 내용에 적용되는 함수의 주소.<br>del: 필요한 경우 노드의 내용을 삭제하는 데 사용되는 함수의 주소. |
| **반환 값** | 새 리스트.<br>할당 실패 시 NULL. |
| **외부 함수** | malloc, free |
| **설명** | 리스트 'lst'를 반복하고 각 노드의 내용에 함수 'f'를 적용하며, 함수 'f'의 연속적인 적용 결과로 생성된 새 리스트를 생성합니다. 'del' 함수는 필요한 경우 노드의 내용을 삭제하는 데 사용됩니다. |

---

## V. README 요구사항

Git 저장소의 루트에 `README.md` 파일을 제공해야 합니다. 이 파일의 목적은 프로젝트에 익숙하지 않은 사람(동료, 교직원, 채용 담당자 등)이 프로젝트가 무엇인지, 실행 방법, 그리고 주제에 대한 추가 정보를 어디서 찾을 수 있는지 빠르게 이해할 수 있도록 하는 것입니다.

`README.md`에는 최소한 다음이 포함되어야 합니다:

- 첫 번째 줄은 이탤릭체로 작성되어야 하며 다음과 같이 읽혀야 합니다: "이 프로젝트는 <login1>[, <login2>[, <login3>[...]]]에 의해 42 커리큘럼의 일부로 생성되었습니다."
- 프로젝트의 목표와 간략한 개요를 포함하여 프로젝트를 명확하게 제시하는 "설명" 섹션.
- 컴파일, 설치 및/또는 실행에 관한 모든 관련 정보를 포함하는 "지침" 섹션.
- 주제와 관련된 고전적인 참고 자료(문서, 기사, 튜토리얼 등) 목록과 AI가 사용된 방법에 대한 설명(어떤 작업과 프로젝트의 어떤 부분에 사용되었는지 명시)을 포함하는 "리소스" 섹션.

➠ 프로젝트에 따라 추가 섹션이 필요할 수 있습니다(예: 사용 예시, 기능 목록, 기술적 선택 등). 필요한 추가 사항은 아래에 명시적으로 나열됩니다.

- 이 프로젝트를 위해 생성된 라이브러리에 대한 자세한 설명도 포함되어야 합니다.

> 언어 선택은 귀하의 재량에 달려 있습니다. 영어로 작성하는 것을 권장하지만 필수는 아닙니다.

---

## VI. 제출 및 동료평가

평소와 같이 Git 저장소에 과제를 제출하세요. 저장소 내의 작업만 동료 평가 중에 평가됩니다. 파일 이름이 올바른지 다시 한 번 확인하세요.

모든 파일을 저장소의 루트에 배치하세요.

평가 중에 프로젝트의 간단한 수정이 가끔 요청될 수 있습니다. 이는 사소한 동작 변경, 몇 줄의 코드 작성 또는 재작성, 또는 추가하기 쉬운 기능을 포함할 수 있습니다.

이 단계가 모든 프로젝트에 적용되지 않을 수 있지만, 평가 지침에 언급된 경우 준비해야 합니다.

이 단계는 프로젝트의 특정 부분에 대한 실제 이해를 확인하기 위한 것입니다. 수정은 선택한 개발 환경(예: 일반적인 설정)에서 수행할 수 있으며, 특정 시간 프레임이 평가의 일부로 정의되지 않는 한 몇 분 내에 가능해야 합니다.

예를 들어, 함수나 스크립트를 약간 업데이트하거나, 디스플레이를 수정하거나, 새 정보를 저장하기 위해 데이터 구조를 조정하도록 요청받을 수 있습니다.

세부 사항(범위, 대상 등)은 평가 지침에 명시되며 동일한 프로젝트에 대해 평가마다 다를 수 있습니다.